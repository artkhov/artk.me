+++
title = "SystemVerilog. Начало. Комбинационные схемы."
description = "Комбинационная логика на SystemVerilog. Модули. Операторы - always_comb, assign, if else, case."
date = 2020-05-10T10:49:22+03:00
draft = false
tags = [
    "SystemVerilog",
    "verilog",
    "модули",
    "комбинационная логика",
    "always_comb",
]
categories = [
    "Языки описания аппаратуры",
]
slug = "systemverilog_module_comb"
+++

В языке SystemVerilog минимальной поведенческой сущностью для описания блоков цифровой аппаратуры служит **модуль**.
Модуль имеет входные и выходные сигналы. В SystemVerilog есть два основных типа сигналов: *logic* и *net*.
<!--more-->
```sv
module func (input logic a, b, c, 
             output logic result);
    assign result = a & b & c;
endmodule: func
```
> В примере выше я описал простой модуль с названием **func**. 
> В данном случае модуль принимает на вход три сигнала **a**, **b**, **c** и отдает на выход один сигнал **result**.
> Все сигналы имеют тип *logic*, который появился в SystemVerilog как замена *reg*. <br>
> `Тип` *logic* `стоит использовать везде, кроме описания сигналов с несколькими источниками.`
---

### Комбинационные схемы
Отличительная особенность комбинационных схем состоит в том,
что значения на выходах определяются только значениями на входе. Комбинационные схемы не имеют состояния,
и не хранят результат предыдущих операций.
<br>
Для описания комбинационных схем в SystemVerilog используются операторы:
##### assign
Оператор непрерывного присваивания, вычисление значения **y** происходит сразу при изменении значения **a**.
```sv
assign y = ~a
```
##### always_comb
**always_comb** появился как расширение оператора **always**, который в общем виде выглядит следующим образом:
```sv
always @(список чувствительности)
```
**always_comb** эквивалентен **always @(\*)**, но **always_comb** предпочтительнее,
т.к. если данный блок будет содержать не только комбинационную логику, SystemVerilog будет выдавать предупреждение.

**always_comb** похож на цикл, который ждет изменения любого значения в правой части уравнений,
как только это происходит, блок выполняется.
```sv
module func (input logic a, b, c, 
      output logic result);
  always_comb
  if (a)
      result = b & c;
  else result = b | c;
endmodule: func
/* Как только поменяется значение на одном из входов(a, b, c)
будет вычислен result */

```
---

#### Операторы выбора и управления

##### if else
Операторы *if* *else* работают по такому же принципу как и в классических языках программирования. 
В общем виде объявление выглядит так:
```sv
if (conditional_expression) statements;
else statement;
```
```sv
// Пример модуля с if else
module if
    (input logic a, b ,c,
     output logic f);

    always_comb begin
        if (a & b) f = 1;
        else if (c & a ^ b)
            f = 1;
        else f = 0;
    end
endmodule: if
```

##### case
```sv
// Обычный case
module exampleCase
    (input logic a, b,
     output logic f);
    
    always_comb
        case ({a, b})
            2'b00: f = 0;
            2'b01: f = 1;
            2'b10: f = 1;
            2'b11: f = 1;
        endcase
endmodule: exampleCase
```
Оператор *case* находит первый подходящий вариант, после чего исполняется оператор справа.
* {a, b} - `{}` оператор конкатенации, позволяет создать новую переменную. Если *a = 0*, *b = 1*, то переменная *{a, b}* будет иметь значение *01*
* конструкция *2'b00* позволяет определить константу с заданной разрядностью.
```sv
3'b011  // 3-битная константа с двоичным значением
3'd8    // 3-битная константа с десятичным значением
3'hA    // 3-битная константа с шестнадцатеричным значением
```

###### unique case
Часто ф-ции задаются не полностью, т.к. часть значений не имеет значения, такие комбинации называются несущественными("don't cares").
```sv
case ({a, b, c})
    3'b000, 3'b001: result = 1;
    3'b101: result = 1;
    3'b100: result = 1;
    3'b111: result = 1;
    default: result = 0; // если значения не совпадает с 3-битными константами сверху,
                         // то выбирается default
endcase
```
> `Если забыть указать оператор default, то наша схема уже не будет комбинационной. Оператор case принимает 3-битную переменную,
> которую мы получаем с помощью оператора конкатенации {} из 3 переменных a, b  и c. У 3-битной переменной может быть восемь возможных значений,
> а мы указали только пять. Инструменты синтеза проанализировав код увидят, что если значение будут 3'b011, 3'b110, 3'b010, 
> то значение result - это результат выполнения предыдущего цикла.`

Оператор *unique case* работает похожим образом, что и *case* с *default*.
Инструменты синтеза, сталкиваясь с оператором *unique case*, будут выдавать ошибку если на вход подаётся недопустимое значение,
которое не перечислено в кейсах.
```sv
unique case ({a, b, c})
    3'b000, 3'b001: result = 1;
    3'b101: result = 1;
    3'b100: result = 1;
    3'b111: result = 1;
endcase
```
---
##### Параметризованные модули
Входной или выходной сигнал типа *logic* может быть не только проводом, но и шиной данных, которая передаёт несколько бит информации.
```sv
module example
        (input logic [1:0] a, b,
         output logic [1:0] result);
endmodule: example
/* Модуль example принимает на вход две 2-битных шины a и b 
на выход 2-битную шину result
*/
```
> a[1:0] - представляет 2-битную шину. <br>
> Биты, от старшего к младшему, записываются: a[1], a[0] - такой порядок бит называется little-endian.
> Когда биты записываются в обратном порядке a[0:1] - такой порядок называется big-endian.

Для того чтобы модули можно было переиспользовать, кол-во бит в шинах может быть задано параметром и переопределятся
в зависимости от контекста вызова и необходимости.
```sv
module exampleParam
        #(parameter W = 8) // шина данных задана через параметр
        (input logic [W-1:0] a, b,
         output logic [W-1:0] result);
endmodule: exampleParam

// вызов модуля exampleParam в другой часте программы
// с переопределением размерности шины данных
module ex2;
    logic a, b, result;
    // переопределение размерности шины
    // она становится 32-битной
    exampleParam (#32) a1 (a, b, result);
endmodule: ex2
```
---

##### Перечисления (enum)
Перечисления в SystemVerilog очень похожы на enum в классических языках программирования.
Использование имен вместо числовых значений уменьшает вероятность ошибки.
```sv
// переменные op1 и op2 - строго типизированы,
// могут принимать одно из трех значений (ADD, MOV, JMP).
enum {ADD, MOV, JMP} op1, op2;
```
> По умолчанию элементы перечесления имеют тип *int* и принимают последовательные значения начиная с 0.
> Можно указать любой [целочисленный тип](/blog/systemverilog_data_types/ "целочисленный тип").
```sv
module: example1;
    enum logic [2:0] {ADD, SUB, AND, OR, XOR} op;
    ...
    always_comb
        unique case (op)
            ADD: result = a + b;
            SUB: result = a - b;
            AND: result = a & b;
            OR:  result = a | b;
            XOR: result = a ^ b;
        endcase
endmodule: example1

module: example2;
    enum logic [2:0]
       {ADD= 3'b001,
        SUB= 3'b011,
        AND= 3'b111,
        OR=  3'b110,
        XOR= 3'b100 } op;
endmodule: example2
```

##### Определение типа (typedef)
Ключевое слово **typedef**, позволяет определить новый тип данных, который можно использовать при определении переменных и портов.
```sv
typedef enum logic [2:0]
       {ADD= 3'b001,
        SUB= 3'b011,
        AND= 3'b111,
        OR=  3'b110,
        XOR= 3'b100 } aluInstruction;

module: alu
    (input logic [3:0] a, b,
     output logic [3:0] result,
     input aluInstruction op);
    
    ...
endmodule: alu
```
